Top-level types can only be declared with `public` or package-private access modifier (see `TopLevelType` file).\
A Java file can have at most one `public` top-level type and its name must match the filename.

Interface - abstract data type that declares a list of abstract methods that any class implementing the interface must provide.
Although this definition is not precise nowadays since new method types are now supported by interfaces.\
See `InterfaceDefinition` file.

When implementing interface's method, `public` access modifier must be used, return type must be covariant and method signature
must match the method signature from the interface.\
If a class implements multiple interfaces, it is possible to override more than one abstract method at the same time with one 
method declaration. Methods must be compatible meaning a method that properly overrides both inherited methods can be written.\
See `ImplementingInterface` file.

An interface can extend another interface using the `extends` keyword.\
An interface can extend multiple interfaces separated by comma after the `extends` keyword.\
When a concrete class inherits an interface, all of the inherited abstract methods must be implemented.

Interface member types:

|                       | Membership | Required modifiers | Implicit modifiers  | Has value or body? |
|-----------------------|------------|--------------------|---------------------|--------------------|
| constant variable     | Class      | -                  | public static final | Yes                |
| abstract method       | Instance   | -                  | public abstract     | No                 |
| default method        | Instance   | default            | public              | Yes                |
| static method         | Class      | static             | public              | Yes                |
| private method        | Instance   | private            | -                   | Yes                |
| private static method | Class      | private static     | -                   | Yes                |

_class_ membership means a member is shared along all instances of the interface.\
_instance_ membership means a member is associated with a particular instance of the interface.

Default interface method _may optionally_ be overridden by a class implementing the interface.\
Default method cannot be marked as `abstract`, `static` or `final`.\
If a class inherits two or more `defaut` methods with the same signature, then the class must override the method.\
See `DefaultMethods` file.

Static interface method cannot be marked as `abstract` or `final`.\
Static interface method cannot be accessed in a class implementing the interface without the reference to the interface name.
It can also be accesses in classes that do not implement the interface (referencing the interface name).

Private methods were added to interfaces primarily to reduce code duplication.\
`default` and `private` non-static interface methods can access `abstract` methods defined in the interface.

An _enumeration_ (or _enum_ for short) is a fix set of constants.\
See `EnumExample` class.

Enum methods:
* `values()` - retrieves an array of all values,
* `name()` - returns string name of the value,
* `ordinal()` - returns ordinal number of the value (starts with 0, depends on the declaration order),
* `valueOf()` - retrieves an enum value from a String.

See `ComplexEnumExample` class.

A _sealed class_ is a class that restricts which other classes may **directly** extend it. These are new to Java 17.\
See `SealedClass` class.\
Important rule #1: a sealed class needs to be declared in the same package or named module as its direct subclasses.\
Important rule #2: each subclass declared after the `permits` keyword must extend the sealed class.\
Important rule #3: each subclass extending a sealed class needs to be `final`, `sealed` or `non-sealed`.\
Important rule #4: `permits` keyword can be omitted if sealed class and subclasses are in the same file. This rule also 
applies to sealed classes with nested subclasses.

Interfaces can also be sealed and many of the rules for classes apply for them.\
Key difference #1: `permits` list can contain classes that implement the interface or interfaces that extend the interface.\
Key difference #2: interfaces extending a sealed interface can be marked as `sealed` or `non-sealed`, but not as `final`.

Encapsulation is a way to protect class members by restricting access to them.\
Records are special immutable types created to get rid of boilerplate code.\
They contain private final fields, getters, constructors, as well as `equals()`, `hashCode()` and `toString()` methods - 
all of which are automatically generated by the compiler.\
See `Records` file.\
Records cannot be extended or inherited.\
Records can implement a regular or sealed interface.\
Instance fields cannot be added outside the record declaration.

Records can contain:
* static fields and methods,
* overloaded and compact constructors,
* instance methods including overriding any provided methods like accessors or `toString()` (`@Override` annotation is optional),
* nested classes, interfaces, annotations, enum and records.

A _nested class_ is a class defined within another class. We distinguish:
* inner class - a non-static type (class / interface / enum / record / annotation) defined at the member level of a class,
* static nested class - a static type defined at the member level of a class,
* local class - a class defined within a method / constructor / instance initializer body,
* anonymous class - a special case of a local class that does not have a name.

See `InnerClass` file.\
Inner classes can have the same variable names as outer class.

Static nested classes can be instantiated without an instance of the enclosing class, however they can't access instance 
members of the enclosing class.

Local classes:
* do not have access modifier,
* can be declared `final` or `abstract`,
* have access to all members of the enclosing class when defined in an instance method,
* can access `final` and effectively final local variables.

See `LocalClass` file.

An anonymous class is declared and instantiated all in one statement using:
* `new` keyword,
* type name with parentheses,
* set of braces.

Anonymous classes must extend an existing class or implement an existing interface.\
See `AnonymousClass` file.\
Anonymous class is just a local class without a name.

Nested classes summary:

| Permitted modifiers | Inner class | `static` nested class | Local class  | Anonymous class |
|---------------------|-------------|-----------------------|--------------|-----------------|
| Access modifiers    | All         | All                   | None         | None            |
| `abstract`          | Yes         | Yes                   | Yes          | No              |
| `final`             | Yes         | Yes                   | Yes          | No              |

| Permitted modifiers                                       | Inner class | `static` nested class | Local class                             | Anonymous class                         |
|-----------------------------------------------------------|-------------|-----------------------|-----------------------------------------|-----------------------------------------|
| Can extend a class or implement any number of interfaces? | Yes         | Yes                   | Yes                                     | No                                      |
| Can access instance members of the enclosing class?       | Yes         | No                    | Yes (if declared in an instance method) | Yes (if declared in an instance method) |
| Can access local variables of enclosing method?           | N/A         | N/A                   | Yes (if `final` or effectively final)   | Yes (if `final` or effectively final)   |

Polymorphism

Java object may be accessed using:
* a reference with the same type as the object,
* a reference that is a superclass of the object,
* a reference that defines an interface the object implements or inherits.

A cast is not required if the object is being reassigned to a supertype or an interface it implements.\
Reassigning to a subtype requires an explicit cast. The subtype must be compatible with the object or 
a `ClassCastException` will be thrown at runtime.\
The compiler disallows casts to unrelated types.

The type of the object determines which properties exist within the object in memory.\
The type of the reference to the object determines which methods and variables are available to the Java program.

The `instanceof` operator also cannot be used with unrelated types.

Remember: when a method is overridden, all calls to it are replaced, even these defined in the parent class.\
On the other hand, hiding members (applies to `static` methods and fields) is sensitive to the reference type and 
the location where the member is used.